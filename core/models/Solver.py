import os
import datetime
from time import perf_counter
import os
import json

from core.models import Schedule
from algorithms.genetic.smart_mut_ga import smart_mut_genetic_algorithm
from algorithms.memetic.memetic import memetic_algorithm
from algorithms.pso.pso import particle_swarm_optimization
from core.logging import UCSPLogger
from core.generators.generate_state import generate_state_from_config
from algorithms.pso.pyswarms import pyswarms


class UCSPSolver:
    """ 
    UCSP Solver

    used to solve UCSP using preferred algorithms.

    The `config_file` should provide enough configurable options for most use cases. Additional (optional) flags can be used to overwrite the configs in `config_file`.

    :param config_file: The JSON file used to configure UCSP solver.  (default: 'ucsp.config.json')
    \n
    :param save_sch: (optional) Boolean to decide whether to save the final schedule or to just display it in console. If `True`, the final encoded schedule is saved in `data/schedules/` with the datetime of when the schedule was generated.
    \n
    :param save_logs: (optional) Boolean to decide whether to save the logs generated by solver i.e. the Generation and Fitness of each iteration of the chosen solver algorithm. The logs will be saved in `data/logs/` with the datetime of when the log was started.
    \n
    :param inspect_final_sch: (optional) Boolean to determine whether to inspect the fitness of the final schedule or not.
    \n

    """

    def __init__(
        self,
        config_file="ucsp.config.json",
        save_sch=None,
        save_logs=None,
        inspect_final_sch=None
    ):
        self._config = self._parse_config_file(config_file)

        self._state = generate_state_from_config(config_file)

        self._logger = UCSPLogger(save_logs or self._config['save_logs'])
        self._save_sch = save_sch or self._config['save_schedule']
        self._inspect_final_sch = inspect_final_sch or self._config['inspect_final_schedule']

    def _parse_config_file(self, fpath):
        with open(fpath) as f:
            return json.load(f)

    def ga(
        self,
        epochs=100,
        population_size=100,
        min_acceptable_fitness=1,
        elite_pct=10,
        mateable_pct=50,
        mutable_pct=25
    ):
        """ Genetic Algorithm 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of individuals in each generation. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param elite_pct: The percentage of elites i.e. the % of top individuals that directly get selected for the next generation. (default: 10)
        \n
        :param mateable_pct: The percentage of top individuals that mate to produce the next generation of the population. (default: 50)
        \n
        :param mutable_pct: The percentage of individuals that could undergo mutation, if that makes them more fit. (default: 25)
        NOTE: we are not using the standard mutation as that leaves the solution worse off, and converges to 0. Rather we are using what we term as `smart mutation`.
        \n
        """
        self._logger.write(
            f"""Running Genetic Algorithm - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; elite_pct: {elite_pct}; mateable_pct: {mateable_pct}; mutable_pct: {mutable_pct};\n"""
        )
        t1 = perf_counter()
        sch = smart_mut_genetic_algorithm(
            self._logger,
            self._state,
            epochs,
            population_size,
            min_acceptable_fitness,
            elite_pct,
            mateable_pct,
            mutable_pct
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def meme(
        self,
        epochs=100,
        min_acceptable_fitness=1,
        population_size=50,
        elite_pct=10,
        mateable_pct=50,
        lcl_search_pct=10,
        lcl_search_iters=30
    ):
        """ Memetic Algorithm 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of individuals in each generation. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param elite_pct: The percentage of elites i.e. the % of top individuals that directly get selected for the next generation. (default: 10)
        \n
        :param mateable_pct: The percentage of top individuals that mate to produce the next generation of the population. (default: 50)
        \n
        :param lcl_search_pct: The percentage of individuals that undergo local search to find a better solution than their current one. (default: 10)
        \n
        :param lcl_search_iters: The maximum number of times an individual chosen for local search - will continue to look for a better solution, if they haven't found one already. (default: 30)
        \n
        """
        self._logger.write(
            f"""Running Memetic Algorithm - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; elite_pct: {elite_pct}; mateable_pct: {mateable_pct}; lcl_search_pct: {lcl_search_pct}; lcl_search_iters: {lcl_search_iters};\n"""
        )

        t1 = perf_counter()
        sch = memetic_algorithm(
            self._logger,
            self._state,
            epochs,
            min_acceptable_fitness,
            population_size,
            elite_pct,
            mateable_pct,
            lcl_search_pct,
            lcl_search_iters,
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def pso(
        self,
        epochs=100,
        population_size=100,
        min_acceptable_fitness=1,
        w0=0.8, wf=0.2, c1=1, c2=2, vmax_pct=5
    ):
        """ Particle Swarm Optimization 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of particles in each iteration. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param w0: The starting weight of each particle. (default: 0.8) 
        \n
        :param wf: The ending weight of each particle. (default: 0.2)
        \n
        :param c1: The weight/coefficient of the individual component in the velocity update equation. (default: 1)
        \n
        :param c2: The weight/coefficient of the social component in the velocity update equation. (default: 2)
        \n
        :param vmax_pct: The maximum velocity percent i.e. the maximum percentage change a particle can undergo in each iteration. (default: 5)
        \n
        """
        self._logger.write(
            f"""Running Particle Swarm Optimization - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; w0: {w0}; wf: {wf}; c1: {c1}; c2: {c2}; vmax_pct: {vmax_pct};\n"""
        )
        t1 = perf_counter()
        sch = particle_swarm_optimization(
            self._logger,
            self._state,
            epochs,
            population_size,
            min_acceptable_fitness,
            w0, wf, c1, c2, vmax_pct
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def pyswarms(
        self,
        epochs=100,
        population_size=100,
        min_acceptable_fitness=1,
        w0=0.8, wf=0.2, c1=1, c2=2, vmax_pct=5
    ):
        """ Particle Swarm Optimization 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of particles in each iteration. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param w0: The starting weight of each particle. (default: 0.8) 
        \n
        :param wf: The ending weight of each particle. (default: 0.2)
        \n
        :param c1: The weight/coefficient of the individual component in the velocity update equation. (default: 1)
        \n
        :param c2: The weight/coefficient of the social component in the velocity update equation. (default: 2)
        \n
        :param vmax_pct: The maximum velocity percent i.e. the maximum percentage change a particle can undergo in each iteration. (default: 5)
        \n
        """
        self._logger.write(
            f"""Running Particle Swarm Optimization - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; w0: {w0}; wf: {wf}; c1: {c1}; c2: {c2}; vmax_pct: {vmax_pct};\n"""
        )
        t1 = perf_counter()
        sch = pyswarms(
            self._logger,
            self._state,
            epochs,
            population_size,
            min_acceptable_fitness,
            w0, wf, c1, c2, vmax_pct
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def _write_schedule(self, sch: Schedule):
        if self._save_sch:
            t = datetime.datetime.now().strftime('%Y-%m-%dT%H-%M-%S')

            fname = os.path.join(
                os.getcwd(), "data/schedules", f"sch-str-{t}.csv")
            with open(fname, "w") as f:
                f.write(sch.to_csv())
            self._logger.write(
                f"\nHuman Readable Schedule successfully saved to {fname}")

            fname = os.path.join(
                os.getcwd(), "data/schedules", f"sch-num-{t}.csv")
            with open(fname, "w") as f:
                f.write(sch.to_num_csv())
            self._logger.write(
                f"\nNumeric Schedule successfully saved to {fname}")
        else:
            print("\nFinal Schedule: \n")
            print(sch.to_tsv())

        fit = self._state.fitness(sch, _inspect=self._inspect_final_sch)
        print(f"Final fitness: {fit}")
