import os
import datetime
from time import perf_counter

from core.parsers.parse_schedule_params import generate_state_from_csv
from core.models import Schedule
from algorithms.genetic.smart_mut_ga import smart_mut_genetic_algorithm
from algorithms.memetic.memetic import memetic_algorithm
from algorithms.pso.pso import particle_swarm_optimization
from core.logging import UCSPLogger
from core.fitness import fitness


class UCSPSolver:
    """ 
    UCSP Solver

    used to solve UCSP using preferred algorithms.

    :param save_sch: Boolean to decide whether to save the final schedule or to just display it in console. If `True`, the final encoded schedule is saved in `data/schedules/` with the datetime of when the schedule was generated. (default: False)
    \n
    :param save_logs: Boolean to decide whether to save the logs generated by solver i.e. the Generation and Fitness of each iteration of the chosen solver algorithm. The logs will be saved in `data/logs/` with the datetime of when the log was started. (default: False)
    \n
    :param params_folder: Path to the folder containing schedule_params to be used to generate the final schedule. To learn more about the schedule_params, refer to `README.md` or the whitepaper. (default: "data/schedule_params/default/")
    \n
    :param inspect_final_sch: Boolean to determine whether to inspect the fitness of the final schedule or not. (default: False)
    \n

    """

    def __init__(
        self,
        save_sch=False,
        save_logs=False,
        params_folder="data/schedule_params/default/",
        inspect_final_sch=False
    ):
        self._state = generate_state_from_csv(params_folder)
        self._logger = UCSPLogger(save_logs)
        self._save_sch = save_sch
        if save_logs:
            self._save_sch = True
        self._inspect_final_sch = inspect_final_sch

    def ga(
        self,
        epochs=100,
        population_size=100,
        min_acceptable_fitness=1,
        elite_pct=10,
        mateable_pct=50,
        mutable_pct=25
    ):
        """ Genetic Algorithm 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of individuals in each generation. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param elite_pct: The percentage of elites i.e. the % of top individuals that directly get selected for the next generation. (default: 10)
        \n
        :param mateable_pct: The percentage of top individuals that mate to produce the next generation of the population. (default: 50)
        \n
        :param mutable_pct: The percentage of individuals that could undergo mutation, if that makes them more fit. (default: 25)
        NOTE: we are not using the standard mutation as that leaves the solution worse off, and converges to 0. Rather we are using what we term as `smart mutation`.
        \n
        """
        self._logger.write(
            f"""Running Genetic Algorithm - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; elite_pct: {elite_pct}; mateable_pct: {mateable_pct}; mutable_pct: {mutable_pct};\n"""
        )
        t1 = perf_counter()
        sch = smart_mut_genetic_algorithm(
            self._logger,
            self._state,
            epochs,
            population_size,
            min_acceptable_fitness,
            elite_pct,
            mateable_pct,
            mutable_pct
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def meme(
        self,
        epochs=100,
        min_acceptable_fitness=1,
        population_size=50,
        elite_pct=10,
        mateable_pct=50,
        lcl_search_pct=10,
        lcl_search_iters=30
    ):
        """ Memetic Algorithm 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of individuals in each generation. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param elite_pct: The percentage of elites i.e. the % of top individuals that directly get selected for the next generation. (default: 10)
        \n
        :param mateable_pct: The percentage of top individuals that mate to produce the next generation of the population. (default: 50)
        \n
        :param lcl_search_pct: The percentage of individuals that undergo local search to find a better solution than their current one. (default: 10)
        \n
        :param lcl_search_iters: The maximum number of times an individual chosen for local search - will continue to look for a better solution, if they haven't found one already. (default: 30)
        \n
        """
        self._logger.write(
            f"""Running Memetic Algorithm - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; elite_pct: {elite_pct}; mateable_pct: {mateable_pct}; lcl_search_pct: {lcl_search_pct}; lcl_search_iters: {lcl_search_iters};\n"""
        )

        t1 = perf_counter()
        sch = memetic_algorithm(
            self._logger,
            self._state,
            epochs,
            min_acceptable_fitness,
            population_size,
            elite_pct,
            mateable_pct,
            lcl_search_pct,
            lcl_search_iters,
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def pso(
        self,
        epochs=100,
        population_size=100,
        min_acceptable_fitness=1,
        w0=0.8, wf=0.2, c1=1, c2=2, vmax_pct=5
    ):
        """ Particle Swarm Optimization 

        :param epochs: The maximum number of iterations to run if `min_acceptable_fitness` is not satisfied. (default: 100) 
        \n
        :param population_size: The size of the population i.e. the number of particles in each iteration. (default: 100)
        \n
        :param min_acceptable_fitness: The minimum acceptable fitness for this solver. Ranges from 0-1, with 1 being perfect solution with not constraint violation. (default: 1)
        \n
        :param w0: The starting weight of each particle. (default: 0.8) 
        \n
        :param wf: The ending weight of each particle. (default: 0.2)
        \n
        :param c1: The weight/coefficient of the individual component in the velocity update equation. (default: 1)
        \n
        :param c2: The weight/coefficient of the social component in the velocity update equation. (default: 2)
        \n
        :param vmax_pct: The maximum velocity percent i.e. the maximum percentage change a particle can undergo in each iteration. (default: 5)
        \n
        """
        self._logger.write(
            f"""Running Particle Swarm Optimization - epochs: {epochs}; population_size: {population_size}; min_acceptable_fitness: {min_acceptable_fitness}; w0: {w0}; wf: {wf}; c1: {c1}; c2: {c2}; vmax_pct: {vmax_pct};\n"""
        )
        t1 = perf_counter()
        sch = particle_swarm_optimization(
            self._logger,
            self._state,
            epochs,
            population_size,
            min_acceptable_fitness,
            w0, wf, c1, c2, vmax_pct
        )
        t2 = perf_counter()
        self._write_schedule(sch)
        self._logger.write(f"\nTime taken: {t2-t1} s")

    def _write_schedule(self, sch: Schedule):
        if self._save_sch:
            t = datetime.datetime.now().strftime('%Y-%m-%dT%H-%M-%S')
            fname = os.path.join(
                os.getcwd(), "data/schedules", f"schedule-{t}.csv")

            with open(fname, "w") as f:
                f.write(sch.to_csv())

            self._logger.write(
                f"\nEncoded schedule successfully saved to {fname}")
        else:
            print("\nFinal Schedule: \n")
            print(sch)

        fit = fitness(sch, _inspect=self._inspect_final_sch)
        print(f"Final fitness: {fit}")
